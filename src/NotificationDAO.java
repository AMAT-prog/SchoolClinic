
import java.security.Timestamp;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.CallableStatement;
import java.time.LocalDateTime;
import java.util.Date;
import java.sql.Types;


public class NotificationDAO {
    public static ObservableList<Notification> findAll() {
        ObservableList<Notification> list = FXCollections.observableArrayList();
        String sql = """
            SELECT notification_id, kind, title, body, severity, is_read,
                   related_type, related_id, due_at, created_at,
                   auto_generated, dismissed_until
              FROM notifications
              WHERE deleted_at   IS NULL
                    AND resolved_at  IS NULL
                    AND (dismissed_until IS NULL OR dismissed_until <= NOW())
              ORDER BY is_read ASC, COALESCE(due_at, created_at) ASC
        """;
        try (Connection con = MySQL.connect();
             PreparedStatement ps = con.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                int id = rs.getInt("notification_id");
                String kind = rs.getString("kind");
                String title = rs.getString("title");
                String body = rs.getString("body");

                Notification.Severity sev = Notification.parseSeverity(rs.getString("severity"));
                boolean isRead = rs.getBoolean("is_read");
                Notification.Type relType = Notification.parseType(rs.getString("related_type"));
                Integer relId = (Integer) rs.getObject("related_id");

                java.sql.Timestamp dueTs = rs.getTimestamp("due_at");
                LocalDateTime due = (dueTs == null) ? null : dueTs.toLocalDateTime();
                LocalDateTime created = rs.getTimestamp("created_at").toLocalDateTime();

                // Create the Notification object
                Notification n = new Notification(
                    id, kind, title, body, sev, isRead, relType, relId, due, created
                );

                // Read new columns from DB
                boolean autoGen = rs.getBoolean("auto_generated");
                n.setAutoGenerated(autoGen);

                Date dismissedDate = rs.getDate("dismissed_until");
                if (dismissedDate != null) {
                    // can add a field in Notification.java to track it if needed
                    // Example:
                    // n.setDismissedUntil(dismissedDate.toLocalDate());
                }

                list.add(n);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return list;
    }

    public static void refreshAuto() {
        try (Connection con = MySQL.connect();
             CallableStatement cs = con.prepareCall("{CALL sp_refresh_notifications()}")) {
            cs.execute();
        } catch (SQLException e) { e.printStackTrace(); }
    }

    public static boolean markRead(int id, boolean read) {
        String sql = "UPDATE notifications SET is_read=? WHERE notification_id=?";
        try (Connection con = MySQL.connect();
             PreparedStatement ps = con.prepareStatement(sql)) {
            ps.setBoolean(1, read);
            ps.setInt(2, id);
            return ps.executeUpdate()==1;
        } catch (SQLException e) { e.printStackTrace(); return false; }
    }

    public static boolean deleteById(int id) {
        try (Connection con = MySQL.connect();
             PreparedStatement ps = con.prepareStatement("DELETE FROM notifications WHERE notification_id=?")) {
            ps.setInt(1, id);
            return ps.executeUpdate()==1;
        } catch (SQLException e) { e.printStackTrace(); return false; }
    }

    public static boolean deleteAllRead() {
        try (Connection con = MySQL.connect();
             PreparedStatement ps = con.prepareStatement("DELETE FROM notifications WHERE is_read=1")) {
            return ps.executeUpdate()>=0;
        } catch (SQLException e) { e.printStackTrace(); return false; }
    }
    
    public static void refreshFromDB() {
        String sql = "{ CALL sp_refresh_notifications() }";
        try (Connection con = MySQL.connect();
             CallableStatement cs = con.prepareCall(sql)) {
            cs.execute();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static boolean markAllRead() {
        String sql = "UPDATE notifications SET is_read=1 WHERE is_read=0";
        try (Connection con = MySQL.connect();
             PreparedStatement ps = con.prepareStatement(sql)) {
            ps.executeUpdate();
            return true;
        } catch (SQLException e) { e.printStackTrace(); return false; }
    }
    
    public static boolean snoozeAuto(String kind, String relatedType, Integer relatedId, int days) {
    // If a row exists, set dismissed_until = today + days
    // If not exists yet, insert a new muted row so the SP still sees the snooze key
    String upsert = """
        INSERT INTO notifications(kind, title, body, severity, is_read,
                                  related_type, related_id, due_at,
                                  auto_generated, dismissed_until)
        VALUES (?, '', '', 'INFO', 1, ?, ?, NULL, 1, DATE_ADD(CURDATE(), INTERVAL ? DAY))
        ON DUPLICATE KEY UPDATE
            dismissed_until = DATE_ADD(CURDATE(), INTERVAL VALUES(dismissed_until) - CURDATE() + ? DAY)
    """;
    // The ON DUPLICATE expression above varies by MySQL version; use a plain UPDATE if you prefer.
    // A simpler, clearer approach is two statements:
    // 1) UPDATE ... WHERE ...; if (rows==0) INSERT ...

    try (Connection con = MySQL.connect()) {
        // Try update first
        String upd = """
            UPDATE notifications
               SET dismissed_until = DATE_ADD(CURDATE(), INTERVAL ? DAY)
             WHERE auto_generated = 1
               AND kind = ?
               AND related_type = ?
               AND related_id = ?
        """;
        try (PreparedStatement ps = con.prepareStatement(upd)) {
            ps.setInt(1, days);
            ps.setString(2, kind);
            ps.setString(3, relatedType);
            if (relatedId == null) ps.setNull(4, Types.INTEGER); else ps.setInt(4, relatedId);
            int rows = ps.executeUpdate();
            if (rows > 0) return true;
        }

        // If nothing to update, insert a muted placeholder for this key
        String ins = """
            INSERT INTO notifications(kind, title, body, severity, is_read,
                                      related_type, related_id, auto_generated, dismissed_until)
            VALUES (?, '', '', 'INFO', 1, ?, ?, 1, DATE_ADD(CURDATE(), INTERVAL ? DAY))
        """;
        try (PreparedStatement ps = con.prepareStatement(ins)) {
            ps.setString(1, kind);
            ps.setString(2, relatedType);
            if (relatedId == null) ps.setNull(3, Types.INTEGER); else ps.setInt(3, relatedId);
            ps.setInt(4, days);
            return ps.executeUpdate() == 1;
        }

    } catch (SQLException ex) {
        ex.printStackTrace();
        return false;
    }
}




}

